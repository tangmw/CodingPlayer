/***********************************************
【问题描述】
有一个长度为2n的数组{a1,a2,a3,...an,b1,b2,b3,...,bn},希望排序后变成{a1,b1,a2,b2,...,an,bn}，
请考虑有没有时间复杂度为O(n)，空间复杂度为O(1)的解法

对这个洗牌问题继续开脑洞--有没有一个表达式能“预知”原数组中的任意元素经变换后的位置呢？
答案是：有的！不过，得再绕一个弯~

为了找出这个表达式，先实现如下：
给一个长度为2n的数组{a1,a2,a3,...an,b1,b2,b3,...,bn},经排序后变成{b1,a1,b2,a2,...,bn,an}
为了找出规律，规定数组从1号位置开始存起
追踪变换前和变换后，各元素的位置变化，可以发现：
1）前n个元素，第i个元素最终到了2*i的位置；
2）后n个元素，第i个元素最终到了2*i-2*n-1的位置
根据除法的取余运算中，若除数小于被除数，取余等于除数；若商为1，则取余等于除数减去被除数
因此，当0<i<2*n时，经排序变换后，到了第(2*i)%(2*n+1)的位置

位置置换法最终得到的结果需要用一个长度与n相同的新数组存起来，空间复杂度为O(n)，然后通过两两交换，
再转存回原数组，位置置换法本身时间复杂度为O(n),而两两交换复杂度也为O(n)，两个相加时间复杂度还是O(n)

当然，这个方法也不能满足题目要求的时间复杂度O(n)空间复杂度O(1)，但也不失为一种可取的思路

下面是位置置换法的实现代码

Author:tmw
date:2017-11-28
************************************************/
#include <stdio.h>
#include <stdlib.h>

#define swap(x,y,t) (t=x,x=y,y=t)

int* shuffle3_position_swap( int* array , int n )//要求数组从1号位置开始存起
{
    int i,exchange;
    int temp[2*n];
    for( i = 1 ; i <= 2*n ; i++ )
        temp[(2*i)%(2*n+1)] = array[i];//位置置换
    for( i = 1 ; i <= 2*n ; i = i+2 )
        swap(temp[i],temp[i+1],exchange);//两两交换成题目要求的形式
    for( i = 1 ; i <= 2*n ; i++ )
        array[i] = temp[i];       //将元素放回原数组
    return array;
}

int main()
{
    printf("测试程序!\n");
    int i;

    int array[11] ={0,1,2,3,4,5,11,22,33,44,55};//数组元素从1号位置开始起效
    printf("原数组为：");
    for(i=1;i<11;i++)
        printf("%d ",array[i]);
    printf("\n");

    shuffle3_position_swap(array,5);

    printf("洗牌后的数组为：");
    for(i=1;i<11;i++)
        printf("%d ",array[i]);
    printf("\n");

    return 0;
}
